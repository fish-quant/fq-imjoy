<docs lang="markdown">
Image viewer for FISH-quant

# Important
COORDINDATES are shown as YX
Points are stored as a nested array, each point is one subarray [Z,Y,Z].

# New features?

## Update image rather than redrawing it 
would be nice to simply add more graphical elements rather than redrawing the whole thing 

## Image layers to show more channels:
https://leafletjs.com/examples/layers-control/


</docs>

<config lang="json">
{
  "name": "FQ-image-viewer",
  "type": "window",
  "tags": [],
  "ui": "",
  "version": "0.0.1",
  "cover": "",
  "description": "Image viewer for FISH-quant.",
  "icon": "extension",
  "inputs": null,
  "outputs": null,
  "api_version": "0.1.7",
  "env": "",
  "requirements": [ 
                    "https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.min.js",
                    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.6.0/leaflet.css",
                    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.6.0/leaflet.js",
                    "https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css",
                    "https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js",
                    "https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.8/spectre.min.css",
                    "https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.8/spectre-exp.min.css",
                    "https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.8/spectre-icons.min.css",
                    "https://use.fontawesome.com/releases/v5.8.2/css/all.css"],
  "dependencies": [],
  "defaults": {"w": 20, "h": 10},
  "runnable": true
}
</config>

<script lang="javascript">
class ImJoyPlugin {

  async setup() {


    document.getElementById('cont_vue_html').innerHTML = (await api.getAttachment('vue_html'));
    const self = this

    this.store = {
      brightness_value: 100,
      selected_region: [],
      callback_return_region: null
    }

    this.app = new Vue({
      el: '#app',
      data: this.store,
      methods: {

        // Brightness slider
        change_brightness: async function(){
          console.log(this.brightness_value)
          const x = document.getElementsByClassName("leaflet-image-layer");
          for (let e of x) { e.style.filter = "brightness(+"+this.brightness_value/100+ ")"; }
        },

        // Button export
        btn_export_region: async function(){
          this.callback_return_region(this.selected_region)
          self.close();
        },

        // Set callback
        set_callback: async function(callback_name, callback_fun){

          switch(callback_name){

            case 'callback_return_region':
              this.callback_return_region = callback_fun;
              break;
          }
        },
      }
    })

    this.circle_prop = {
        color: 'red',
        fillColor: '#f03',
        fillOpacity: 0.5,
        radius: 2
    }

    this.selected_prop = {
        color: 'red',
        fillColor: '#f03',
        fillOpacity: 0.2,
        weight: 4,
    }

    this.not_selected_prop = {
        color: 'blue',
        fillColor: 'white',
        fillOpacity: 0.0,
        weight: 3,
    }

    api.log('initialized')
  }

  async run(ctx) {

    console.log('[FQ-image-viewer] received data: ')
    console.log(ctx['data'])

    var self = this

    // Initiate map 
    var map = L.map('img_id', {
        crs: L.CRS.Simple,
        minZoom: -3
    });

    // Some default parameters to test the interface
    var url_load = 'https://imgs.xkcd.com/comics/online_communities.png'
    var img_shape = [1000,1000]

    // Read callback: return region
    if (ctx['data']['callback_return_region'] != null){
      this.app.set_callback('callback_return_region', ctx['data']['callback_return_region'])
    } 

    // Read image data 
    if (ctx['data']['url'] != null){
      url_load = ctx['data']['url']
      img_shape = ctx['data']['shape']
    }
 

    // Layer of actual image
    var bounds = [[0,0], [img_shape[0]-1,img_shape[1]-1]];
    var image = L.imageOverlay(url_load, bounds);
    map.addLayer(image)
    map.fitBounds(bounds);

    // Points. Mapping considers different orientation of y-axis ... if not present also define some default points
    if (ctx['data']['points'] != null){
      points = ctx['data']['points']
    }else {
      var points = [[0,0,0],[0,img_shape[0]-1,img_shape[1]-1]]   // Ideally this is removed at one point
    }

    var pos_array = points.map(pos => L.circle([img_shape[0] -pos[1]-1, pos[2]],this.circle_prop))
    var points = L.layerGroup(pos_array)
    map.addLayer(points)

    // For overlay controls: might be overwritten when an annotation layer is added
    var overlayMaps = {
      "Detected points": points
    };

    // Add controls for manual annotation
    if (this.store.callback_return_region != null){
        // Initialise the FeatureGroup to store editable layers
        var editableLayers = new L.FeatureGroup();
        map.addLayer(editableLayers);

        overlayMaps = {
          "Detected points": points,
          "Manual selection":editableLayers
        };

        // Initialise the draw control and pass it the FeatureGroup of editable layers
        var drawPluginOptions = {
          position: 'bottomleft',
          
          draw: {
            rectangle: true,
            // disable toolbar item by setting it to false
            polygon: false, polyline: false, circle: false, marker: false,
            },

          edit: {
            featureGroup: editableLayers, //REQUIRED!!
            edit: false
          }
        };

        var drawControl = new L.Control.Draw(drawPluginOptions);
        map.addControl(drawControl);

        // When draw element is created
        map.on('draw:created', function(e) {
          var layer = e.layer;

          editableLayers.addLayer(layer).on('click', function(e){
            var layer = e.layer;
            self.store.selected_region = layer.getBounds().toBBoxString()
            editableLayers.setStyle(self.not_selected_prop)
            layer.setStyle(self.selected_prop);
          });

          editableLayers.setStyle(self.not_selected_prop)
        });
    }

    // Overlay controls
    var baseMaps = {
      "Image": image,
    };

   L.control.layers(baseMaps,overlayMaps,{position: 'topleft', collapsed: this.screenWidth<600}).addTo(map);

  }
}

api.export(new ImJoyPlugin())
</script>

 
<attachment name="vue_html">
    
   <div>
 
    <div class="input-group">
      <span class="input-group-addon" style="background-color:#eff5fa">Brightness</span>
      <input class="slider" type="range" min="0" max="200" v-model.number="brightness_value" v-on:click="change_brightness" >
      <button class="btn btn-lg" v-if="callback_return_region" @click="btn_export_region"><i class="space-left-right icon icon-share"></i></button>
    <!-- <button class="btn btn-lg" title="draw" id="btn_draw"><i class="icon icon-edit"></i></button> -->
    <!-- <button class="btn btn-lg" title="delete" id="btn_draw"><i class="icon icon-delete"></i></button> -->
    </div>
  </div>

     <div id="img_id"></div>
</attachment>


<window lang="html">

  <div id="app">
    <div id="cont_vue_html"> </div> 
  </div>

</window>

<style lang="css">

#img_id {   
  height: calc(100% - 40px);
  width: 100%
}

.space-left-right {
     margin-left: 5px;
     margin-right: 5px;
}

.leaflet-image-layer {
    -webkit-filter: brightness(1); /* Safari */
    filter: brightness(1);
}

</style>
