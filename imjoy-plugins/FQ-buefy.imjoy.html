<docs lang="markdown">
[TODO: write documentation for this plugin.]
</docs>

<config lang="json">
{
  "name": "FQ-buefy",
  "type": "window",
  "tags": [],
  "ui": "",
  "version": "0.1.0",
  "cover": "",
  "description": "[TODO: describe this plugin with one sentence.]",
  "icon": "extension",
  "inputs": null,
  "outputs": null,
  "api_version": "0.1.8",
  "env": "",
  "permissions": [],
    "requirements": [
                      "https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.min.js",
                      "https://cdn.jsdelivr.net/npm/bulma@0.8.2/css/bulma.min.css",
                      "https://cdn.materialdesignicons.com/2.5.94/css/materialdesignicons.min.css",
                      "https://unpkg.com/buefy/dist/buefy.min.js",
                      "https://unpkg.com/buefy/dist/buefy.min.css"
                      ],
  "dependencies": [],
  "defaults": {"w": 20, "h": 10}
}
</config>

<script lang="javascript">
class ImJoyPlugin {
  async setup() {

    const self = this

    // Render different tabs with attachments
    document.getElementById('cont_data').innerHTML = (await api.getAttachment('data'));
   
    // Get plugins from workspace
    this.fq_worker = await api.getPlugin("FISH-QUANT")
    console.log('FQ-worker: ' +  this.fq_worker)
    this.fq_viewer = await api.getPlugin("FQ-image-viewer")

    // Get file-manager of FQ plugin
    const fq_worker_url = await this.fq_worker.get_engine_url()
    console.log('URL of connected FQ-worker: ' +  fq_worker_url)

    // Get default values (if store already)
    var reg_exp = await api.getConfig('reg_exp')
    if(! reg_exp) {
      reg_exp = '(?P<fov>.*)-(?P<file_ident>Exp.*)_(?P<channel>.*)\\.(?P<img_ext>.*)'
    }

    var data_path = await api.getConfig('data_path')
    if(! data_path) {
      data_path = 'paste-path-to-data'
      data_path = 'D:\Documents\Data\test-data\fish-quant\spot-detection\acquisition'
    }

    var sigma_xy =  parseFloat(await api.getConfig('sigma_xy'));
    if(! sigma_xy) {sigma_xy = 0.75}

    var sigma_z = parseFloat(await api.getConfig('sigma_z'));
    if(! sigma_z) {sigma_z = 1}

    this.store = {
          active_tab: 'data',
          txt_navbar: 'Specify and open image for processing',
          fq_worker: this.fq_worker,
          fq_worker_url: fq_worker_url,
          files: [],
          file_loaded: '',
          data_path: 'S:\\Documents\\Data\\test-data\\fish-quant\\spot-detection\\acquisition', //data_path, 
          output_path:"acquisition>>analysis",
          channels: [],
          analysis_region: [],
          ch_name: [],
          ch_ident: [],
          reg_exp: reg_exp,
          pixel_size_xy: await api.getConfig('pixel_size_xy'),
          pixel_size_z:  await api.getConfig('pixel_size_z'),
          images: [],
          current_index: 0,
          channel_selected: null,
          sigma: [sigma_z, sigma_xy, sigma_xy],  // ZYX
          minimum_distance: 2,
          detetection_plot: [],
          detection_threshold: null,
          img_filt: [],
          img_filt_load : null,
          img_filt_min:0,
          img_filt_max:0,
          th_range_min:0,
          th_range_max:5000,
          th_range_nbins:50,
          status_image_loaded: false,
          status_image_filtered: false,
          status_channel_selected: false,
          status_thresholds_tested: false,
          status_detection_applied: false,
          carousels: [
                { text: 'Slide 1', color: 'primary' },
                { text: 'Slide 2', color: 'info' },
                { text: 'Slide 3', color: 'success' },
                { text: 'Slide 4', color: 'warning' },
                { text: 'Slide 5', color: 'danger' }
            ],
    },

    this.app = new Vue({
      el: '#app',
      data: this.store,

      methods: {
          
          // Open URL in external window
          openUrl(url){
              api.utils.openUrl(url)
          },

          // Data: remove channel
          remove_channel: function(ch) {
            this.channels.splice(this.channels.indexOf(ch), 1);
          },

          // Data: add channel
          add_channel: function() {
            this.channels.push({name: this.ch_name,identifier: this.ch_ident})
            // Reset fields
            this.ch_name = []
            this.ch_ident = []
          },

          // Scan data directory
          btn_scan_folder: async function() {
            let config = {channels: this.channels,
                          reg_exp: this.reg_exp,
                          data_path: this.data_path}
            let file_list  = await this.fq_worker.scan_folder(config)

            // Get all channel names
            let ch_names = this.channels.map(channel => channel['name'])

            // Replace file list
            this.files = []
            file_list.map(update_files.bind(this))
            console.log(file_list)

            function update_files(file){
              let file_info = {
                    file_ident: file['file_ident'],
                    fov: file['fov'],
                    img_ext: file['img_ext']
              }

              // Assign all channel names
              ch_names.map(function(ch_name){
                file_info[ch_name] = file[ch_name]
              })

              this.files.push(file_info)
            }
          },

          // Load image
          btn_load_image: async function(file){
            self.load_image(file)
          },

          showImageFilt(obj){
                  this.img_filt = obj
              },

          showImage(obj){
              this.images.push(obj)
              if(this.images.length>5){
                  this.images.shift()
              }
              this.current_index = this.images.length -1
          },

          setThreshold(threshold){
                  this.detection_threshold = threshold
          },


          // Select region for analysis
          btn_select_analysis_region: async function(file){
            self.select_analysis_region(file)
          },


          // Callback to save filtered image
          dblclick_show_image_raw: async function(channel_selected){
            console.log(channel_selected)
            this.fq_worker.show_image({
                        'channel_selected': channel_selected,
                        'image_type': 'raw',
                        'image_dim': 'mip',
                        'display_type': 'dialog'
                        })
          },

          // Callback to filter image
          btn_filter_image: async function(){
            self.filter_image()
          },

          // Callback to show filtered image: as resizable window
          btn_show_image_filtered: async function(){
            this.fq_worker.show_image({
                        'channel_selected': this.channel_selected,
                        'image_type': 'filtered',
                        'image_dim': 'mip',
                        'display_type': 'window'
                        })
          },

          // Callback to show filtered image: as dialog
          dblclick_show_image_filtered: async function(){
            this.fq_worker.show_image({
                        'channel_selected': this.channel_selected,
                        'image_type': 'filtered',
                        'image_dim': 'mip',
                        'display_type': 'dialog'
                        })
          },

          // Callback to save filtered image
          btn_save_image_filtered: async function(){
            self.save_image_filtered()
          },

          // Callback to plot detections detection
          btn_detection_test_thresholds: async function(){
            self.detection_test_thresholds()
          },

          // Callback to plot detections detection
          btn_detection_apply: async function(){
            self.detection_apply()
          },

          // Callback to plot detections detection
          btn_detection_GMM: async function(){
            console.log('to be implemented')
          },

          // Callback to plot detections detection
          btn_detection_batch: async function(){
            self.detection_batch()
          },

          // Callback to plot detections detection
          btn_detection_file: async function(){
            self.detection_file()
          },




      } // END methods vue
    }) // END vue
  } // END SETUP


  // Load images
  async load_image(file) {

      // Reset all processing parameters
      this.store.images = []
      this.store.img_filt = []
      this.store.analysis_region = []

      this.store.status_image_loaded = true
      this.store.channel_selected = null
      this.store.status_image_filtered = false
      this.store.status_thresholds_tested = false
      this.store.status_detection_applied = false

      let graph_detection = document.getElementById('graph_detection');
      if (graph_detection != null){
          Plotly.purge(graph_detection);
      };

      // Load image
      let mips = await this.fq_worker.load_image({
                            'file': file,
                            'channels': this.store.channels,
                            'data_path': this.store.data_path,
                            'output_path': this.store.output_path,
                            'create_mips': true,
                            'show_status': true,
                            })

      this.store.txt_navbar = 'Loaded image IDENTIFIER :: FOV  :  ' + file.file_ident + ' :: ' + file.fov;
      this.store.file_loaded = file;

      // Assign images to carousel
      mips.map(mip => this.app.showImage({
                            'url': mip.url,
                            'index': mip.channel,
                            'key': Date.now(),
                            'channel': mip.channel,
                            'shape': mip.shape,
                            })
      )
      
      // Store parameters for next launch
      api.setConfig('data_path', this.store.data_path)
      api.setConfig('reg_exp', this.store.reg_exp)
      api.setConfig('pixel_size_xy', this.store.pixel_size_xy)
      api.setConfig('pixel_size_z', this.store.pixel_size_z)
  }


  // Select a region for analysis
  async set_analysis_region(coords) {
    console.log('[FISH-quant] Obtained coordinates:' + coords)
    this.store.analysis_region = coords
  }

  async select_analysis_region() {

    // Get image corresponding to selected channel
    var img_selected = this.store.images.find(obj => {
      return obj.channel === this.store.channel_selected
    })

    if (img_selected === undefined){
      api.alert('Select a channel first')
      return
    }
    console.log('[FQ] sending data to viewer.')
    
    await this.fq_viewer.run({'data':{
                              'url': img_selected['url'],
                              'shape':img_selected['shape'],
                              'callback_return_region': this.set_analysis_region}
                              })

  }

  // Filter image
  async filter_image() {

      this.store.img_filt = []

      this.store.img_filt_load = await this.fq_worker.filter_image({
                            'sigma': this.store.sigma,
                            'channel_selected': this.store.channel_selected,
                            'data_path': this.store.data_path,
                            'output_path': this.store.output_path,
                            'create_mips': true,
                            'show_status': true,
                            'selected_region': this.store.analysis_region,
                            })

      this.app.showImageFilt({
                    'url': this.store.img_filt_load['url'],
                    'meta': 'loaded image'
                    })

      this.store.img_filt_min = this.store.img_filt_load['min']
      this.store.img_filt_max = this.store.img_filt_load['max']

      this.store.status_image_filtered = true

      // Set filtering parameters for next load of FQ
      api.setConfig('sigma_xy', this.store.sigma[1])
      api.setConfig('sigma_z', this.store.sigma[0])
  }


  // Save filtered image
  async save_image_filtered() {

      this.fq_worker.save_image_filtered({
                            'data_path': this.store.data_path,
                            'output_path': this.store.output_path,
                            'channel_selected': this.store.channel_selected,
                            })
  }

 async plot_detection_test(th_tests){
   console.log(th_tests)
 }


  // Test thresholds for detection
  async detection_test_thresholds() {

    this.store.status_thresholds_tested = true

    var th_tests = await this.fq_worker.detect_test_thresholds({
                              'threshold_range': [this.store.th_range_min,
                                                  this.store.th_range_max,
                                                  this.store.th_range_nbins],
                              'sigma': this.store.sigma,
                              'minimum_distance': this.store.minimum_distance,
                              'show_status': true,
                              })

    this.store.status_thresholds_tested = true

    // Create plotly plot
    var graph_detection = document.getElementById('graph_detection');
    
    var data = [{
          x: th_tests[0],
          y: th_tests[1],
          mode: "lines+markers",
          type: 'scatter'
        }],
        layout = {
                    hovermode:'closest',
                    xaxis: { title: { text: 'Intensity threshold'}},
                    yaxis: { title: { text: '# detected spots'}},
        }

    await Plotly.newPlot('graph_detection', data, layout, {responsive: true});
    
    graph_detection.on('plotly_click', async (data) => {
          var txt = '',
              th = [],
              n_spots = []
          for(var i=0; i < data.points.length; i++){
            th = data.points[i].x,
            n_spots = data.points[i].y
            txt = 'Threshold = '+ th +'\nN_spots = '+ n_spots + '\n\n';
          }
          this.app.setThreshold(th)
    });
 
    this.store.detetection_plot = await Plotly.toImage('graph_detection', {format: 'png', width: 800, height: 600})
  
  }


  // Test thresholds for detection
  async detection_apply() {

    if ( this.store.detection_threshold == null){
      api.alert('Please set a numeric value to test the intensity threshold!')
      return
    }
    var spots = await this.fq_worker.detect_apply({
                              'detection_threshold': this.store.detection_threshold,
                              'sigma': this.store.sigma,
                              'show_status': true,
                              'detection_plot': this.store.detetection_plot
                              })

    this.fq_viewer.run({'data':{
                              'url': this.store.img_filt_load['url'],
                              'shape':this.store.img_filt_load['shape'],
                              'points':spots}
                              })

    this.store.status_detection_applied = true
  }

  // Detect current file
  async detection_file() {

    this.fq_worker.detection_file({

                      // To scan folder and store results
                      'channels': this.store.channels,
                      'channel_selected': this.store.channel_selected,
                      'reg_exp': this.store.reg_exp,
                      'data_path': this.store.data_path,
                      'output_path': this.store.output_path,
                      'channel_selected': this.store.channel_selected,

                      // Filter & detection
                      'sigma': this.store.sigma,
                      'minimum_distance': this.store.minimum_distance,
                      'detection_threshold': this.store.detection_threshold,
                      });


  }


  // Batch detection
  async detection_batch() {

    this.fq_worker.detection_batch({
      
                      // To scan folder and store results
                      'channels': this.store.channels,
                      'reg_exp': this.store.reg_exp,
                      'data_path': this.store.data_path,
                      'output_path': this.store.output_path,
                      'channel_selected': this.store.channel_selected,

                      // Filter & detection
                      'sigma': this.store.sigma,
                      'minimum_distance': this.store.minimum_distance,
                      'detection_threshold': this.store.detection_threshold,
                      })
  }

  async run(ctx) {
  }
}

api.export(new ImJoyPlugin())
</script>

<attachment name="data">
  <!-- Card to specify data -->
  <div class="card">
    <div class="card-content">

      <!-- Summary -->
      <div class="summary">
        <div class="summary-content">
          <p class="title is-4">Specify data</p>
          <p class="subtitle is-7">Specify images to be loaded and analyzed. </p>
        </div>
      </div>
      <br>

      <!-- Actual content -->
      <div class="content">

        <!-- Specify folders -->
        <b-field horizontal label="DATA folder">
          <b-input v-model="data_path" placeholder="paste-path-to-data"></b-input>
        </b-field>
        <b-field horizontal label="RESULTS folder">
          <b-input v-model="output_path" placeholder=""></b-input>
        </b-field>

        <!-- Specify regular expression -->
        <section>
          <b-field label="Regular expression" horizontal grouped>
            <b-input v-model="reg_exp" expanded></b-input>
            <p class="control">
              <b-button class="button is-primary" @click="openUrl('https://pythex.org/?regex='+reg_exp)">Test regexp</button>
            </p>
          </b-field>
        </section>

        <!-- Specify pixel size -->
        <b-field horizontal label="Pixel-size in nm">
          <b-input v-model="pixel_size_xy" expanded></b-input>
        </b-field>
        <b-field horizontal label="Z step-size in nm">
          <b-input v-model="pixel_size_z" expanded></b-input>
        </b-field>

        <!--Specify channels -->
         <br>
        <section>
          <div class="columns">
            <div class="column">
              <b-field label="Name" label-position="on-border">
                <b-input placeholder="Name of channel" v-model="ch_name"></b-input>
              </b-field>
            </div>
            <div class="column">
              <b-field label="Identifier" label-position="on-border">
                <b-input placeholder="Unique string" v-model="ch_ident"></b-input>
              </b-field>
            </div>
            <div class="column">
              <b-button icon-left="plus-circle" @click="add_channel" :disabled="ch_name.length==0 || ch_ident.length==0">Add</b-button>
            </div>
          </div>
        </section> <!-- END: Specify channels -->

        <!-- CHANNELS: render table containing channels to be loaded -->
       
        <div style="text-align: center;">
          <table class="table is-striped is-hoverable is-narrow">
            <thead>
              <tr>
                <th>Name</th>
                <th>Identifier</th>
                <th>Remove?</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="ch in channels" :key="ch.name">
                <td>{{ch.name}}</td>
                <td>{{ch.identifier}}</td>
                <td>
                  <b-button class="b-button" icon-left="delete" @click="remove_channel(ch)"> </b-button>
                </td>
              </tr>
            </tbody>
          </table>
        </div> <!-- END: CHANNELS: table containing channels to be loaded -->

        <br>
        <b-button expanded type="is-primary" :disabled="channels.length==0" @click="btn_scan_folder">Scan folder for all files fitting the search criteria</b-button>

      </div> <!-- END Class content -->
    </div> <!-- END class card-content -->
  </div> <!-- END class card -->

  <!-- Card to specify data -->
  <div class="card">
    <div class="card-content">

      <!-- Summary -->
      <div class="summary">
        <div class="summary-content">
          <p class="title is-4">Data in folder fitting search criteria</p>
          <p class="subtitle is-7">Load one dataset for analysis. </p>
        </div>
      </div>
      <br>

      <!-- Actual content -->
      <div class="content">

        <div class="columns is-desktop">

          <!-- Table with files that can be loaded -->
          <div class="column">
            <table class="table is-striped is-hoverable is-narrow">
              <thead>
                <tr>
                  <th>Identifier</th>
                  <th>FOV</th>
                  <th>Load image</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="file in files" :key="file.file_ident" v-bind:class="{'is-selected':(file === file_loaded)}">
                  <td>{{file.file_ident}}</td>
                  <td>{{file.fov}}</td>
                  <td>
                    <b-button icon-left="upload" @click="btn_load_image(file)"></b-button>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- Image carousel with loaded images-->
          <div class="column">
            <div>
              <b-carousel autoplay=false v-if="images.length" :indicator-inside="false">
                <b-carousel-item v-for="(img, i) in images" :key="i">
                  <img class="img-responsive rounded" style="margin-top: 5px; max-height: 600px;" v-bind:src="img.url" :alt="img.index" v-on:dblclick="dblclick_show_image_raw(img.index)">
                </b-carousel-item>
                <template slot="indicators" slot-scope="props">
                  <span class="al image">
                    <!-- <img :src="images[props.i" :title="props.i"> -->
                    <!--<p v-bind="channels[props.i].name" expanded>asdfasd</p> -->
                    <span> {{ channels[props.i].name }}</span>
                  </span>
                </template>
              </b-carousel>
            </div>
          </div>
        </div>





        





      </div> <!-- END Class content -->
    </div> <!-- END class card-content -->
  </div> <!-- END class card -->

</attachment>

<!--  <b-menu-item icon="help-circle" label="Documentation"  @click="openUrl('https://fish-quant.github.io/fq-imjoy')"></b-menu-item> -->
<!--   <b-menu-item icon="github-circle" label="Github" @click="openUrl('https://github.com/fish-quant/fq-imjoy')"></b-menu-item> -->

<window lang="html">
  <div>

    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>

    <div id="app">

      <!-- Navbar -->
      <template>
          <b-navbar>
              <template slot="brand">
                  <b-navbar-item tag="router-link" :to="{ path: '/' }">
                      <img
                          src="https://raw.githubusercontent.com/fish-quant/fq-imjoy/master/docs/img/fish-quant-logo_200x200.png"
                          alt="Lightweight UI components for Vue.js based on Bulma"
                      >
                  </b-navbar-item>
                  <b-navbar-item href="#">
                      <a @click="openUrl('https://github.com/fish-quant/fq-imjoy')" class="btn btn-link"> 
                      <b-icon icon="github-circle" size="is-small"></b-icon> GitHub</a>
                  </b-navbar-item>
                  <b-navbar-item href="#">
                      <a @click="openUrl('https://fish-quant.github.io/fq-imjoy')" class="btn btn-link">
                      <b-icon icon="help-circle" size="is-small"></b-icon> Documentation</a>
                  </b-navbar-item>
              </template>

           </b-navbar>
      </template>


      <!-- Tabs -->
      <b-tabs type="is-toggle" position="is-centered">
        <b-tab-item label="1. Data specifications" icon="google-photos">
          <div id="cont_data"></div>
        </b-tab-item>
        <b-tab-item label="2. Spot detection" icon="library-music">
        </b-tab-item>
        <b-tab-item label="3.Postprocessing" icon="video">
        </b-tab-item>
      </b-tabs>

    </div> <!-- END div APP -->
  </div> <!-- END of master div -->
</window> <!-- END Class card -->

<style lang="css">
.is-active .al img {
    font-weight: bold;
}
.al img {
    font-weight: bold;
}
</style>
